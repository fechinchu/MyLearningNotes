# 数据结构与算法12-字符串匹配算法

# 1.BF算法

BF算法(Brute Force)中文叫做暴力匹配算法,也叫朴素匹配算法.

有两个概念:在字符串A中查找字符串B,那字符串A就是**主串**,字符串B就是**模式串**;

BF算法的思想如下图:

![image-20210813163739316](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813163739316.png)

BF算法的时间复杂度很高,是`O(n*m)`,m是模式串的长度,n是主串的长度;

# 2.RK算法

RK算法的全称叫做Rabin-Karp算法.是发明者Rabin和Karp的名字来命名的.

如果模式串长度为m,主串长度为n,那在主串中,就会有n-m+1个长度为m的子串,我们只需要暴力地对比这n-m+1个子串与模式串,就可以找出主串与模式串匹配的子串;

我们通过哈希算法对主串中的n-m+1个子串分别求哈希值,然后逐个与模式串的哈希值比较大小,如果某个子串的哈希值与模式串相等,那就说明对应的子串与模式串匹配了.

![image-20210813164835116](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813164835116.png)

# 3.BM算法

## 3.1.BM算法的核心思想

将模式串和主串的匹配过程,看作是模式串在主串中不停的往后移动,当遇到不匹配的字符串.在下图的例子中,主串中的c,在模式串中是不存在的,所以,模式串向后滑动的时候,只要c与模式串没有重合,肯定无法匹配.所以我们可以一次性把模式串往后多滑动几位,把模式串移动到c的后面.

![image-20210813170957913](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813170957913.png)

BM算法的本质,就是在寻找这种规律,借助这种规律,在模式串与主串匹配的过程中,当模式串与主串某个字符串不匹配的时候,能够跳过一些肯定不会匹配的情况,将模式串往后多滑动几位;

## 3.2.坏字符规则

BM算法的匹配顺序是按照模式串下标从大到小的顺序倒着匹配的.

![image-20210813171946365](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813171946365.png)

从模式串的末尾往前倒着匹配,当发现某个字符没法匹配的时候,我们把这个没有匹配的字符串叫做**坏字符**(主串中的字符);

![image-20210813172154890](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813172154890.png)

拿坏字符c在模式串中查找,发现模式串中并不存在这个字符,也就是说,字符c与模式串中的任何字符都不可能匹配.这个时候,就可以将模式串直接往后滑动三位,将模式串滑动到c后面的位置.再从模式串的末尾字符开始比较;

![image-20210813172338666](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813172338666.png)

这个时候,可以看到,模式串中最后一个字符d,还是无法跟主串中的a匹配,这个时候就不能将模式串往后滑动三位了,因为这个时候,坏字符a在模式串中是存在的,模式串中下标是0的位置也是字符a.这种情况下,我们可以将模式串往后滑动2位,让两个a上下对齐.然后再从模式串的末尾字符开始,重新匹配;

![image-20210813172717494](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813172717494.png)

当发生不匹配的时候,把坏字符对应的模式串中的字符下标记为`si`.如果坏字符在模式串中存在,把这个坏字符在模式串中的下标记作`xi`;如果不存在,把xi记作-1.那模式串往后移动的位数就等于si-xi;如果坏字符在模式串里多出出现,在计算xi的时候,选择最靠后的,这样不会让模式串滑动过多,导致本来可能匹配的情况被滑动略过;

![image-20210813173206666](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813173206666.png)

利用坏字符规则，BM 算法在最好情况下的时间复杂度非常低，是 O(n/m);

## 3.3.好后缀规则

![image-20210813175523832](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813175523832.png)

如上图,模式串和主串有2个字符是匹配的,倒数第3个字符发生了不匹配的情况;

我们把已经匹配的bc叫做好后缀,叫做{u}.我们拿它在模式串中查找,如果找到了另一个根{u}相匹配的子串{u\*}.那我们就将模式串滑动到子串{u\*}与主串中{u}对齐的位置;



![image-20210813180027038](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813180027038.png)

如果在模式串中找不到另一个等于{u}的子串,就直接将模式串,滑动到主串中{u}的后面,因为之前的任何一次往后滑动,都没有匹配主串中{u}的情况;

![image-20210813180232421](https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813180232421.png)

不过,当模式串中不存在等于{u}的子串时候,我们直接将模式串滑动到主串{u}的后面,会容易出现问题,如下图所示,就会错过模式串和主串可以匹配的情况

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813192836322.png" alt="image-20210813192836322" style="zoom: 50%;" />

## 3.4.BM算法代码实现

当遇到坏字符时候,要计算往后移动的位数si-xi,.如果我们拿到坏字符,在模式串中顺序遍历查找,这样就会比较低效;我们可以将模式串中的每个字符及其下标都存在散列表中.

关于散列表,我们假设字符串的字符集不是很大,每个字符长度是1字节,用大小为256的数组,来记录每个字符在模式串中出现的位置.数组的下标对应字符的ASCII码值,数组中存储这个字符在模式串中出现的位置;

<img src="https://fechin-picgo.oss-cn-shanghai.aliyuncs.com/PicGo/image-20210813194631193.png" alt="image-20210813194631193" style="zoom:50%;" />

~~~java
private static final int SIZE = 256; // 全局变量或成员变量
private void generateBC(char[] b, int m, int[] bc) {
  for (int i = 0; i < SIZE; ++i) {
    bc[i] = -1; // 初始化bc
  }
  for (int i = 0; i < m; ++i) {
    int ascii = (int)b[i]; // 计算b[i]的ASCII值
    bc[ascii] = i;
  }
}
~~~

BM算法框架如下:

~~~java
public int bm(char[] a, int n, char[] b, int m) {
  int[] bc = new int[SIZE]; // 记录模式串中每个字符最后出现的位置
  generateBC(b, m, bc); // 构建坏字符哈希表
  int i = 0; // i表示主串与模式串对齐的第一个字符
  while (i <= n - m) {
    int j;
    for (j = m - 1; j >= 0; --j) { // 模式串从后往前匹配
      if (a[i+j] != b[j]) break; // 坏字符对应模式串中的下标是j
    }
    if (j < 0) {
      return i; // 匹配成功，返回主串与模式串第一个匹配的字符的位置
    }
    // 这里等同于将模式串往后滑动j-bc[(int)a[i+j]]位
    i = i + (j - bc[(int)a[i+j]]); 
  }
  return -1;
}
~~~

