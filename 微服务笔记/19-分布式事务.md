# Education项目总结19-分布式事务

# 1.订单与选课需求分析

# 2.分布式事务

## 2.1.问题描述

用户支付完成会将支付状态及订单状态保存在订单数据库中.由订单服务去维护订单数据库.而学生选课信息在学习中心数据库,由学习服务去维护学习中心数据库的信息.下图是系统结构图;

![image-20200517141053021](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517141053021.png)

如何实现两个分布式服务(订单服务,学习服务)共同完成一件事即订单支付成功自动添加学生选课的需求,这里的关键是如何保证两个分布式服务的事务的一致性;

尝试解决上边的需求,在订单服务中远程调用选课接口,伪代码如下:

~~~
订单支持结果通知方法{
	更新支付表中支付状态为"成功";
	远程调用选课接口添加选课记录;
}
~~~

上边的逻辑说明:

1. 更新支付表状态为本地数据库操作;
2. 远程调用选课接口为网络远程调用请求;
3. 为保存事务上边两步操作由Spring控制事务,当遇到Exception异常则回滚本地数据库操作;

问题如下:

1. 如果更新支付表失败则抛出异常,不再执行远程调用,此设想没有问题;
2. 如果更新支付表成功,网络远程调用超时会拉长本地数据库事务时间,影响数据库性能;
3. 如果更新支付表成功,远程调用添加选课成功(选课数据库commit成功),最后更新支付表commit失败,此时出现操作不一致;

## 2.2.什么是分布式事务

1. 什么是事务?

   事务是指由一组操作组成的一个工作单元,这个工作单元具有原子性(atomicity),一致性(consistency),隔离性(isolation)和持久性(durability);

   *原子性*:执行单元中的操作要么全部执行成功,要么全部失败.如果有一部分成功一部分失败那么成功的操作要全部回滚到执行前的状态;

   *一致性*:执行一次失误会使用数据从一个正确的状态转换到另一个正确的状态,执行前后数据都是完整的.

   *隔离性*:在该事务执行的过程中,任何数据的改变只存在于该事务之中,对外界没有影响,事务与事务之间是完全隔离带.只有事务提交后其他事务才可以查询到最新的数据;

   *持久性*:事务完成后对数据的改变会永久性的存储起来,即使发生断电宕机数据依然在;

2. 什么是本地事务?

   本地事务就是用关系数据库来控制事务,关系数据库通常都具有ACID特性,传统的单体应用通常会将数据全部存储在一个数据库中,会借助关系数据库来完成事务控制;

3. 什么是分布式事务?

   在分布式系统中一次操作由多个系统协同完成,这种一次事务操作设计多个系统通过网络协同完成的过程称为分布式事务.这里强调的是多个系统通过网络协同完成一个事务的过程,并不强调多个系统访问不同的数据库,即使多个系统访问的是同一个数据库也是分布式事务.

   ![image-20200517144211129](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517144211129.png)

## 2.3.CAP理论

如何进行分布式事务控制?CAP理论是分布式事务处理的理论基础.

CAP理论是:**分布式系统在设计时只能在一致性(Consistency),可用性(Availability),分区容忍性(PartitionTolerance)中满足两种,无法兼顾三种**;

![image-20200517144439729](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517144439729.png)

* **一致性(Consistency)**:服务A,B,C三个节点都存储了用户数据,三个节点的数据需要保持同一时刻数据一致性;
* **可用性(Availability):**服务A,B,C三个节点,其中一个节点宕机不影响整个集群对外提供服务;
* **分区容忍性(PartitionTolerance):**分区容忍性就是允许系统通过网络协同工作,分区容忍性要解决由于网络分区导致数据的不完整及无法访问等问题;

分布式系统能否兼顾C,A,P?

在保证分区容忍性的前提下一致性和可用性无法兼顾.如果要提高系统可用性就要增加多个节点,如果要保证数据的一致性就要实现每个节点的数据一致,节点越多可用性越好,但数据的一致性越差;

CAP的组合方式:

1. CA:放弃分区容忍性,加强一致性和可用性,关系数据库按照CA进行设计;
2. AP:放弃一致性,加强可用性和分区容忍性,追求最终一致性,很多NoSQL数据库按照AP进行设计.当然这里放弃一致性是指放弃强一致性.强一致性就是写入成功立刻要查出最新数据.追求最终一致性是指允许暂时的数据不一样,只要最终在用户接受的时间内数据一致即可.
3. CP:放弃可用性,加强一致性和分区容忍性,一些强一致性要求的系统按CP进行设计,比如跨行转账,一次转账请求要等待双方银行系统都完成整个事务才算完成.由于网络问题的存在CP系统可能会出现等待超时,如果没有处理超时问题整个系统会出现阻塞;

**在分布式系统设计中AP的应用较多,即保证分区容忍性和可用性,牺牲数据的强一致性,保证数据最终一致性;**

## 2.4.解决方案

### 2.4.1.两阶段提交协议(2PC)

为解决分布式系统的数据一致性问题出现了两阶段提交协议(2 Phase Commitment Protocol),两阶段提交由协调者和参与者组成,共经过两阶段和三个操作,部分关系数据库如Oracle,MySQL支持两阶段提交协议,本节讲解关系数据库两极端提交协议;

![image-20200517171122173](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517171122173.png)

1. 第一阶段:准备阶段(prepare)

   协调者通知参与者准备提交订单,参与者开始投票;协调者完成准备工作向协调者回应Yes;

2. 第二阶段:提交(commit)/回滚(rollback)阶段;

   协调者根据参与者的投票结果发起最终的提交指令.如果有参与者没有准备好则发起回滚指令,

![image-20200517171458987](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517171458987.png)

* 优点:实现强一致性,部分关系数据库支持(Oracle,MySQL等);

* 缺点:整个事务的执行需要由协调者在多个节点之间协调,增加了事务的执行时间,性能低下;

  解决方案有:SpringBoot+Atomikos or Bitronix;

### 2.4.2.事务补偿(TCC)

TCC事务补偿是基于2PC实现的业务层事务控制方案,它是Try,Confirm和Cancel三个单词的首字母;

1. Try检查及预留业务资源,完成提交事务前的检查,并预留好资源;
2. Confirm确定执行业务操作;对try阶段预留的资源正式执行;
3. Cancel取消执行业务操作,对try阶段预留的资源释放;

![image-20200517172125785](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517172125785.png)

* 优点:最终保证数据的一致性,在业务层实现事务控制,灵活性好;

* 缺点:开发成本高,每个事务操作每个参与者都需要实现try/confirm/cancel三个接口;

注意:TCC的try/confirm/cancel接口都要实现幂等,在try,confirm,cancel失败后要不断重试;

实现幂等操作的方式有:

1. 操作之前在业务方法进行判断如果执行过了就不再执行;
2. 缓存所有请求和处理的结果,已经处理的请求则直接返回结果;
3. 在数据库表中加一个状态字段(未处理,已处理),数据操作时判断未处理时再处理;

### 2.4.3.消息队列实现最终一致

本方案是将分布式事务拆分成多个本地事务来完成,并且由消息队列异步协调完成;

![          ](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517172956433.png)

1. 订单服务和库存服务完成检查和预留资源;

2. 订单服务在本地事务中完成添加订单表记录和添加"减少库存任务消息";
3. 由定时任务根据消息表的记录发送给MQ通知库存服务执行减库存操作;
4. 库存服务执行减少库存,并且记录执行消息状态(未避免重复执行消息,在执行减库存之前查询是否执行过此消息);
5. 库存服务向MQ发送完成减少库存的消息;
6. 订单服务接收到完成库存减少的消息后删除原来添加的"减少库存消息";

实现最终事务一致要求:**预留资源成功理论上要求正式执行成功,如果执行失败会进行重试,要求业务执行方法实现幂等**;

* 优点:由MQ按异步的方式协调完成事务,性能较高;不用实现try/confirm/cancel接口,开发成本比TCC低;
* 缺点:此方式基于关系数据库本地事务来实现,会出现频繁读写数据库记录,浪费数据库资源,另外对于高并发操作不是最佳方案;

## 2.5.自动添加选课方案

![image-20200517185043764](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200517185043764.png)

1. 支付成功后,订单服务向本地数据库更新订单并向消息表写入"添加选课消息",通过本地数据库保证订单状态和添加选课消息的事务;
2. 定时任务扫描消息表,取出"添加选课任务"并发向MQ;
3. 学习服务接收到添加选课的消息,先查询本地数据库的历史消息表是否存在消息,存在则说明已经添加选课,否则向本地数据库添加选课,并向历史消息表添加选课消息,这里选课表和历史消息表在同一个数据库,通过本地事务保证;
4. 学习服务接收到添加选课的消息,通过查询消息表判断如果已经添加选课也向MQ发送"完成添加选课任务的消息",否则则添加选课,完成后向MQ发送"完成添加选课任务的消息";
5. 订单服务接收到完成选课的消息后删除订单数据库中消息表的"添加选课消息",为保证后期对账将消息表的消息先添加到历史消息表再删除消息,表示此消息已经完成.

# 3.Spring Task定时任务(略)

## 3.1.Spring Task串行执行任务

定义任务1和定义任务2发现他们是串行执行的;

## 3.2.Spring Task并行执行任务

创建异步任务配置类,需要配置线程池实现多线程调度任务

~~~java
@Configuration
@EnableScheduling
public class AsyncTaskConfig implements SchedulingConfigurer, AsyncConfigurer {
    //线程池线程数量
    private int corePoolSize = 5;

    @Bean
    public ThreadPoolTaskScheduler taskScheduler()
    {
        ThreadPoolTaskScheduler scheduler = new ThreadPoolTaskScheduler();
        scheduler.initialize();//初始化线程池
        scheduler.setPoolSize(corePoolSize);//线程池容量
        return scheduler;
    }

    @Override
    public Executor getAsyncExecutor() {
        Executor executor = taskScheduler();
        return executor;
    }

    @Override
    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() {
        return null;
    }

    @Override
    public void configureTasks(ScheduledTaskRegistrar scheduledTaskRegistrar) {
        scheduledTaskRegistrar.setTaskScheduler(taskScheduler());
    }
}
~~~



# 4.订单服务定时发送消息

## 4.1.需求分析

定时任务发送消息流程如下:

1. 每隔1分钟扫描一次任务表
2. 定时任务扫描task表,一次取出多个任务,取出超过1分钟未处理的任务;
3. 考虑订单服务可能集群部署,为避免重复发送任务使用乐观锁的方式每次从任务列表取出要处理的任务;
4. 任务发送完毕更新任务发送时间;

![image-20200519094943241](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20200519094943241.png)

