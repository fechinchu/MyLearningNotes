# 线程安全问题

# 1.Java线程安全之可见性

## 1.1.JIT编译器(Just In Time Compiler)

脚本语言与编译语言的区别?

* 解释执行:咱们说的脚本,在执行时,由语言的解释器将其一条条翻译成机器可识别的指令;
* 编译执行:将我们编译的程序,直接编译成机器可以识别的指令码;

Java是脚本语言还是编译语言?Java是介于脚本语言和编译语言之间;

![image-20210107170649689](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20210107170649689.png)

## 1.2.Java内存模型(JMM)

### 1.2.1.Java内存模型的抽象结构

> 参考<<Java并发编程的艺术>>第三章--Java内存模型

在Java中所有实例域,静态域和数组元素都存储在堆内存中,堆内存在线程之间共享(本章用"共享变量"这个术语代指实例域,静态域和数组元素).局部变量,方法定义参数和异常处理器参数不会在线程之间共享,它们不会有内存可见性问题,也不受内存模型的影响

Java线程之间的通信由Java内存模型(JMM)控制,JMM决定了一个线程对共享变量的写入何时对另一个线程可见.从抽象的角度来看,JMM定义了线程和主内存之间的抽象关系;线程之间的共享变量存储在主内存中(Main Memory)中.每个线程都有一个私有的本地内存(Local Memory),本地内存中存储了该线程以读/写共享变量的副本.本地内存是JMM的一个抽象概念,并不真实存在.它涵盖了缓存,写缓冲区,寄存器以及其他的硬件和编译器优化.

<img src="https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20210108095248727.png" alt="image-20210108095248727" style="zoom: 50%;" />

### 1.2.2.从源代码到指令序列的重排序

在执行程序时,为了提高性能,编译器和处理器常常会对指令重排序.重排序分3种类型;

1. 编译器优化的重排序,编译器在不改变单线程程序语义的前提下,可以重新安排语句的执行顺序;
2. 指令级并行的重排序.现代处理器采用了指令级并行技术来讲多条指令重叠执行.如果不存在数据依赖性,处理器可以改变语句对应机器指令的执行顺序;
3. 内存系统的重排序,由于处理器使用缓存和读/写缓冲区,这使得加载和存储操作看上去可能是在乱序中执行;

上述的1属于编译器重排序,2和3属于处理器重排序.这些重排序可能会导致多线程出现内存可见性问题;对于编译器,JMM的编译器排序规则会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止).对于处理器重排序,JMM的处理器排序规则会要求Java编译器在生成指令排序时,插入特定类型的内存屏障,通过内存屏障指令来禁止特定类型的处理器重排序.

JMM属于语言级的内存排序,它确保在不同的编译器和不同的处理器平台之上,通过禁止特定类型的编译器重排序和处理器重排序,为程序员提供一致的内存可见性保证;

### 1.2.3.并发编程模型的分类

现代处理器的使用写缓冲区临时保存向内存写入的数据.写缓冲区可以保证指令流水线持续运行,它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟.同时,通过以批处理的方式刷新写缓冲区,以及合并写缓冲区对同一内存地址的多次写,减少以内存总线的占用.虽然写缓冲区有这么多的好处,但每个处理器上的写缓冲区,仅仅对它所在的处理器可见.这个特性会对内存的操作顺序产生重要的影响:处理器对内存的读/写操作的执行顺序,不一定与内存实际发生的读/写操作顺序一致.

![image-20210108102622363](https://fechin-leyou.oss-cn-beijing.aliyuncs.com/PicGo/image-20210108102622363.png)

### 1.2.4.happens-before

从JDK5开始,Java使用新的JSR-133内存模型.JSR-133使用happens-before的概念来阐述操作之间的内存可见性,那么这两个操作之间必须要存在happes-before关系.

* 程序顺序规则:一个线程中的每个操作:happens-before于该线程中的任意后续操作;
* 监视器锁规则:对一个锁的解锁,happens-before于随后对这个锁的加锁;
* volatile变量规则:对一个volatile域的写,happens-before于任意后续对这个volatile域的读;
* 传递性:如果A happens-before B,且B happens-before C,那么A happens-before C;

